<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Configurable WebUSB Sender/Receiver</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 1em;
        }

        #status {
            margin-bottom: 1em;
            font-weight: bold;
        }

        #config input,
        #sendConfig input,
        #sendConfig select,
        #sendConfig textarea,
        #sendConfig .radio-group input {
            margin-bottom: 0.5em;
            padding: 5px;
            vertical-align: middle;
        }

        #sendConfig .radio-group label {
            margin-right: 10px;
            font-weight: normal;
            width: auto;
            text-align: left;
        }

        #config label,
        #sendConfig label {
            display: inline-block;
            width: 220px;
            /* Adjusted for potentially longer labels */
            text-align: right;
            margin-right: 5px;
            vertical-align: middle;
        }

        #sendConfig label[for^="deviceConfigJson"],
        #sendConfig label[for^="rawFullCommandJson"],
        #sendConfig label[for^="customJsonMessage"],
        #sendConfig label[for^="invalidTextMessage"],
        #sendConfig label[for^="mappingsConfigJson"] {
            display: block;
            text-align: left;
            width: auto;
            margin-bottom: 3px;
        }


        #config,
        #sendConfig {
            border: 1px solid #eee;
            padding: 1em;
            margin-bottom: 1em;
            background-color: #f9f9f9;
        }

        #sendConfig fieldset {
            margin-top: 10px;
            border: 1px dashed #ccc;
            padding: 10px;
        }

        #sendConfig fieldset legend {
            font-weight: bold;
        }

        #sendConfig fieldset fieldset {
            /* Nested fieldsets */
            margin-top: 5px;
            border-style: dotted;
            padding: 8px;
        }


        #controls,
        #receiveArea {
            margin-top: 1em;
        }

        #receivedData {
            width: 95%;
            height: 200px;
            border: 1px solid #ccc;
            overflow-y: scroll;
            white-space: pre-wrap;
            font-family: monospace;
            margin-top: 0.5em;
            padding: 5px;
        }

        button {
            margin-right: 5px;
            padding: 5px 10px;
        }
    </style>
</head>

<body>

    <h1>WebUSB Configurable Communication</h1>

    <div id="status">Disconnected.</div>

    <fieldset id="config">
        <legend>Device Configuration</legend>
        <div>
            <label for="vid">Vendor ID (hex):</label>
            <input type="text" id="vid" value="0x5AA6">
        </div>
        <div>
            <label for="pid">Product ID (hex):</label>
            <input type="text" id="pid" value="0x60E1">
        </div>
        <div>
            <label for="interface">Interface #:</label>
            <input type="number" id="interface" value="1" min="0">
        </div>
        <div>
            <label for="epOut">OUT Endpoint #:</label>
            <input type="number" id="epOut" value="2" min="1">
        </div>
        <div>
            <label for="epIn">IN Endpoint #:</label>
            <input type="number" id="epIn" value="2" min="1">
        </div>
    </fieldset>

    <button id="connectButton">Connect to USB Device</button>
    <button id="disconnectButton" disabled>Disconnect</button>

    <div id="controls" style="display: none;">
        <hr>
        <fieldset id="sendConfig">
            <legend>Send Data</legend>
            <div>
                <label for="customHeader">Message Header (4-byte hex):</label>
                <input type="text" id="customHeader" value="E59DECC0" maxlength="8" style="width: 100px;">
            </div>
            <br>

            <div>
                <label for="messageType">Message Type:</label>
                <select id="messageType">
                    <option value="getConfig" selected>GetConfig Command</option>
                    <option value="setConfig">SetConfig Command</option>
                    <option value="customJson">Custom JSON Message</option>
                    <option value="invalidText">Invalid Text Message</option>
                    <option value="emptyPayload">Empty Message</option>
                </select>
            </div>

            <div id="commandInputModeDiv" style="display:none; margin-top:10px;" class="radio-group">
                <label style="width:auto;">Input Mode for Command:</label>
                <input type="radio" id="inputModeStructured" name="commandInputMode" value="structured" checked>
                <label for="inputModeStructured">Structured Fields</label>
                <input type="radio" id="inputModeRaw" name="commandInputMode" value="raw">
                <label for="inputModeRaw">Raw Full Command JSON</label>
            </div>

            <fieldset id="structuredFieldsContainer" style="display:none;">
                <legend>Structured Command Fields</legend>
                <fieldset id="protocolHeaderFields" style="display:none;">
                    <legend>Protocol Header</legend>
                    <div>
                        <label for="protocolVersion">Version (uint32):</label>
                        <input type="number" id="protocolVersion" value="65536">
                    </div>
                    <div>
                        <label for="correlationId">Correlation ID (number, opt.):</label>
                        <input type="text" id="correlationId" placeholder="e.g., 12345 (optional)">
                    </div>
                </fieldset>

                <fieldset id="setConfigCommandFields" style="display:none;">
                    <legend>SetConfig Command `config` Object</legend>
                    <div class="radio-group">
                        <label style="width:auto;">Input `config` Object As:</label>
                        <input type="radio" id="inputConfigAsJson" name="setConfigInputMode" value="json" checked>
                        <label for="inputConfigAsJson">JSON Textarea</label>
                        <input type="radio" id="inputConfigAsFields" name="setConfigInputMode" value="fields">
                        <label for="inputConfigAsFields">Individual Fields</label>
                    </div>

                    <div id="setConfigJsonContainer" style="display:none;">
                        <label for="deviceConfigJson">`config` Object (JSON format):</label>
                        <textarea id="deviceConfigJson" rows="5" style="width: 90%;"
                            placeholder='''{"settings": {"wifi": {"ssid": "test", "password": "test"}}, "mappings": {}}'''></textarea>
                    </div>

                    <div id="setConfigIndividualFieldsContainer" style="display:none;">
                        <fieldset id="deviceSettingsFields">
                            <legend>Device Settings (`settings`)</legend>
                            <div>
                                <input type="checkbox" id="provideWifiSettings" style="width:auto;">
                                <label for="provideWifiSettings" style="width:auto; text-align:left;">Provide Wi-Fi
                                    Settings?</label>
                            </div>
                            <fieldset id="wifiSettingsFieldsContainer" style="display:none;">
                                <legend>Wi-Fi Settings (`settings.wifi`)</legend>
                                <div>
                                    <label for="wifiSsid">SSID:</label>
                                    <input type="text" id="wifiSsid" placeholder="Your WiFi SSID">
                                </div>
                                <div>
                                    <label for="wifiPassword">Password:</label>
                                    <input type="text" id="wifiPassword" placeholder="Your WiFi Password">
                                </div>
                            </fieldset>
                            <div>
                                <input type="checkbox" id="provideTimezoneOffset" style="width:auto;">
                                <label for="provideTimezoneOffset" style="width:auto; text-align:left;">Provide Timezone
                                    Offset?</label>
                            </div>
                            <div id="timezoneOffsetFieldContainer" style="display:none;">
                                <label for="timezoneOffset">Timezone Offset (e.g., -7.0, 5.5):</label>
                                <input type="number" step="0.01" id="timezoneOffset" placeholder="0.0">
                            </div>
                        </fieldset>
                        <fieldset id="mappingsConfigFields">
                            <legend>Mappings Configuration (`mappings`)</legend>
                            <label for="mappingsConfigJson">`mappings` Object (JSON format):</label>
                            <textarea id="mappingsConfigJson" rows="5" style="width: 90%;"
                                placeholder='''{"type": "Matrix", "matrix": [], ...}'''></textarea>
                            <small>Note: Individual fields for MappingsConfiguration are not yet implemented. Provide as
                                JSON.</small>
                        </fieldset>
                    </div>
                </fieldset>
            </fieldset>

            <fieldset id="rawFullCommandJsonContainer" style="display:none;">
                <legend>Raw Full Command JSON</legend>
                <label for="rawFullCommandJson">Enter full JSON for the selected command type:</label>
                <textarea id="rawFullCommandJson" rows="5" style="width: 90%;"
                    placeholder='''e.g., {"type": "GetConfig", "header": {"version": 65536}}'''></textarea>
            </fieldset>

            <fieldset id="customJsonMessageFields" style="display:none;">
                <legend>Custom JSON Message</legend>
                <label for="customJsonMessage">Payload for Custom JSON Message:</label>
                <textarea id="customJsonMessage" rows="4" style="width: 90%;"
                    placeholder='''{"custom_key": "custom_value"}'''></textarea>
            </fieldset>

            <fieldset id="invalidTextMessageFields" style="display:none;">
                <legend>Invalid Text Message</legend>
                <label for="invalidTextMessage">Payload for Invalid Text Message:</label>
                <textarea id="invalidTextMessage" rows="4" style="width: 90%;"
                    placeholder='''This is not valid JSON {data: true}'''></textarea>
            </fieldset>

            <button id="sendButton" style="margin-top:15px;">Send Message</button>
        </fieldset>
    </div>

    <div id="receiveArea" style="display: none;">
        <h2>Received Data</h2>
        <pre id="receivedData"></pre>
    </div>

    <script>
        // References to Configuration Inputs
        const vidInput = document.getElementById('vid');
        const pidInput = document.getElementById('pid');
        const interfaceInput = document.getElementById('interface');
        const epOutInput = document.getElementById('epOut');
        const epInInput = document.getElementById('epIn');

        // Other UI References
        const connectButton = document.getElementById('connectButton');
        const disconnectButton = document.getElementById('disconnectButton');
        const sendButton = document.getElementById('sendButton');
        const receivedDataTextArea = document.getElementById('receivedData');
        const statusDisplay = document.getElementById('status');
        const controlsDiv = document.getElementById('controls');
        const receiveAreaDiv = document.getElementById('receiveArea');
        const configFieldset = document.getElementById('config');

        // New UI elements for sending data
        const customHeaderInput = document.getElementById('customHeader');
        const messageTypeSelect = document.getElementById('messageType');
        const commandInputModeDiv = document.getElementById('commandInputModeDiv');
        const inputModeStructuredRadio = document.getElementById('inputModeStructured');
        const inputModeRawRadio = document.getElementById('inputModeRaw');

        const structuredFieldsContainer = document.getElementById('structuredFieldsContainer');
        const protocolHeaderFieldsDiv = document.getElementById('protocolHeaderFields');
        const protocolVersionInput = document.getElementById('protocolVersion');
        const correlationIdInput = document.getElementById('correlationId');

        const setConfigCommandFields = document.getElementById('setConfigCommandFields');
        const inputConfigAsJsonRadio = document.getElementById('inputConfigAsJson');
        const inputConfigAsFieldsRadio = document.getElementById('inputConfigAsFields');
        const setConfigJsonContainer = document.getElementById('setConfigJsonContainer');
        const deviceConfigJsonTextarea = document.getElementById('deviceConfigJson');
        const setConfigIndividualFieldsContainer = document.getElementById('setConfigIndividualFieldsContainer');
        const deviceSettingsFields = document.getElementById('deviceSettingsFields');
        const provideWifiSettingsCheckbox = document.getElementById('provideWifiSettings');
        const wifiSettingsFieldsContainer = document.getElementById('wifiSettingsFieldsContainer');
        const wifiSsidInput = document.getElementById('wifiSsid');
        const wifiPasswordInput = document.getElementById('wifiPassword');
        const provideTimezoneOffsetCheckbox = document.getElementById('provideTimezoneOffset');
        const timezoneOffsetFieldContainer = document.getElementById('timezoneOffsetFieldContainer');
        const timezoneOffsetInput = document.getElementById('timezoneOffset');
        const mappingsConfigFields = document.getElementById('mappingsConfigFields');
        const mappingsConfigJsonTextarea = document.getElementById('mappingsConfigJson');

        const rawFullCommandJsonContainer = document.getElementById('rawFullCommandJsonContainer');
        const rawFullCommandJsonTextarea = document.getElementById('rawFullCommandJson');

        const customJsonMessageFieldsDiv = document.getElementById('customJsonMessageFields');
        const customJsonMessageTextarea = document.getElementById('customJsonMessage');
        const invalidTextMessageFieldsDiv = document.getElementById('invalidTextMessageFields');
        const invalidTextMessageTextarea = document.getElementById('invalidTextMessage');


        let device = null;
        let isReading = false; // Flag to prevent multiple read loops
        // Store parsed config values for the current connection
        let currentInterfaceNumber = 0;
        let currentEndpointOut = 0;
        let currentEndpointIn = 0;

        // New variables for receiving and parsing framed messages
        let receiveBuffer = new Uint8Array(0);
        const EXPECTED_MAGIC_WORD_VALUE = 0xE59DECC0; // As defined in Rust (0xE59DECC0)
        const MAX_EXPECTED_PAYLOAD_LENGTH = 4 * 1024; // Matching MAX_PAYLOAD_LENGTH in usb.rs
        let receiveState = 'AWAITING_MAGIC_WORD'; // Possible states: 'AWAITING_MAGIC_WORD', 'AWAITING_LENGTH', 'AWAITING_PAYLOAD'
        let expectedPayloadLength = 0;

        // Helper function to append an ArrayBuffer to a Uint8Array
        function appendBuffer(existingUint8Array, newArrayBuffer) {
            const newUint8Array = new Uint8Array(newArrayBuffer);
            const totalLength = existingUint8Array.length + newUint8Array.length;
            const result = new Uint8Array(totalLength);
            result.set(existingUint8Array, 0);
            result.set(newUint8Array, existingUint8Array.length);
            return result;
        }

        function processReceiveBuffer() {
            let processedSomething = true; // To loop if multiple messages are in buffer
            while (processedSomething) {
                processedSomething = false;

                if (receiveState === 'AWAITING_MAGIC_WORD') {
                    if (receiveBuffer.length >= 4) {
                        const view = new DataView(receiveBuffer.buffer, receiveBuffer.byteOffset, 4);
                        const magicWord = view.getUint32(0, true); // true for little-endian

                        if (magicWord === EXPECTED_MAGIC_WORD_VALUE) {
                            receiveBuffer = receiveBuffer.slice(4);
                            receiveState = 'AWAITING_LENGTH';
                            processedSomething = true;
                            console.log("Magic word found. Awaiting length.");
                        } else {
                            console.warn(`Invalid magic word found: 0x${magicWord.toString(16)}. Expected: 0x${EXPECTED_MAGIC_WORD_VALUE.toString(16)}. Discarding 1 byte.`);
                            receivedDataTextArea.textContent += `[DEBUG] Invalid magic word: 0x${magicWord.toString(16)}. Discarding 1 byte.\n`;
                            receiveBuffer = receiveBuffer.slice(1); // Basic resync: discard one byte
                            processedSomething = true;
                        }
                    } else {
                        break; // Not enough data for magic word
                    }
                }

                if (receiveState === 'AWAITING_LENGTH') {
                    if (receiveBuffer.length >= 4) {
                        const view = new DataView(receiveBuffer.buffer, receiveBuffer.byteOffset, 4);
                        expectedPayloadLength = view.getUint32(0, true); // true for little-endian
                        receiveBuffer = receiveBuffer.slice(4);

                        if (expectedPayloadLength > 0 && expectedPayloadLength <= MAX_EXPECTED_PAYLOAD_LENGTH) {
                            receiveState = 'AWAITING_PAYLOAD';
                            processedSomething = true;
                            console.log(`Expected payload length: ${expectedPayloadLength}. Awaiting payload.`);
                        } else {
                            console.error(`Invalid payload length: ${expectedPayloadLength}. Max is ${MAX_EXPECTED_PAYLOAD_LENGTH}. Resetting state.`);
                            receivedDataTextArea.textContent += `[ERROR] Invalid payload length: ${expectedPayloadLength}. Resetting.\n`;
                            receiveState = 'AWAITING_MAGIC_WORD';
                            processedSomething = true;
                        }
                    } else {
                        break; // Not enough data for length
                    }
                }

                if (receiveState === 'AWAITING_PAYLOAD') {
                    if (receiveBuffer.length >= expectedPayloadLength) {
                        const payloadBytes = receiveBuffer.slice(0, expectedPayloadLength);
                        receiveBuffer = receiveBuffer.slice(expectedPayloadLength);

                        const payloadJsonString = new TextDecoder().decode(payloadBytes);
                        console.log("Received raw payload string:", payloadJsonString);
                        try {
                            const parsedResponse = JSON.parse(payloadJsonString);
                            receivedDataTextArea.textContent += `Received: ${JSON.stringify(parsedResponse, null, 2)}\n\n`;
                        } catch (e) {
                            console.error("Error parsing JSON payload:", e, "Raw:", payloadJsonString);
                            receivedDataTextArea.textContent += `Error parsing JSON: ${e.message}\nRaw: ${payloadJsonString}\n\n`;
                        }
                        receivedDataTextArea.scrollTop = receivedDataTextArea.scrollHeight;
                        receiveState = 'AWAITING_MAGIC_WORD';
                        processedSomething = true;
                        console.log("Payload processed. Awaiting magic word.");
                    } else {
                        break; // Not enough data for payload
                    }
                }
            }
        }

        // Helper function to convert a hex string to Uint8Array
        function hexStringToUint8Array(hexString) {
            if (hexString.startsWith('0x')) {
                hexString = hexString.substring(2);
            }
            if (hexString.length !== 8) {
                throw new Error("Hex header must be exactly 4 bytes (8 hex characters). Example: E59DECC0");
            }
            if (!/^[0-9a-fA-F]{8}$/.test(hexString)) {
                throw new Error("Hex header contains invalid characters. Only 0-9 and A-F are allowed.");
            }
            const byteArray = new Uint8Array(4);
            for (let i = 0; i < 4; i++) {
                byteArray[i] = parseInt(hexString.substring(i * 2, i * 2 + 2), 16);
                if (isNaN(byteArray[i])) {
                    throw new Error(`Invalid hex character sequence in header at byte ${i}`);
                }
            }
            return byteArray;
        }

        // Helper function to convert a u32 number to a 4-byte Big Endian Uint8Array
        function u32ToBigEndianBytes(num) {
            const buffer = new ArrayBuffer(4);
            const view = new DataView(buffer);
            view.setUint32(0, num, false); // false for big-endian
            return new Uint8Array(buffer);
        }

        // Update UI based on message type and input mode selection
        function updateSendUI() {
            const selectedMessageType = messageTypeSelect.value;
            const selectedCommandInputMode = document.querySelector('input[name="commandInputMode"]:checked').value;
            const selectedSetConfigInputMode = document.querySelector('input[name="setConfigInputMode"]:checked').value;

            // Hide all conditional sections first
            commandInputModeDiv.style.display = 'none';
            structuredFieldsContainer.style.display = 'none';
            protocolHeaderFieldsDiv.style.display = 'none';
            setConfigCommandFields.style.display = 'none';
            setConfigJsonContainer.style.display = 'none';
            setConfigIndividualFieldsContainer.style.display = 'none';
            deviceSettingsFields.style.display = 'none'; // Also ensure nested ones are hidden by default
            wifiSettingsFieldsContainer.style.display = 'none';
            timezoneOffsetFieldContainer.style.display = 'none';
            mappingsConfigFields.style.display = 'none';
            rawFullCommandJsonContainer.style.display = 'none';
            customJsonMessageFieldsDiv.style.display = 'none';
            invalidTextMessageFieldsDiv.style.display = 'none';

            if (selectedMessageType === 'getConfig' || selectedMessageType === 'setConfig') {
                commandInputModeDiv.style.display = 'block';
                if (selectedCommandInputMode === 'structured') {
                    structuredFieldsContainer.style.display = 'block';
                    protocolHeaderFieldsDiv.style.display = 'block';
                    if (selectedMessageType === 'setConfig') {
                        setConfigCommandFields.style.display = 'block';
                        if (selectedSetConfigInputMode === 'json') {
                            setConfigJsonContainer.style.display = 'block';
                        } else { // fields for setConfig.config
                            setConfigIndividualFieldsContainer.style.display = 'block';
                            deviceSettingsFields.style.display = 'block';
                            provideWifiSettingsCheckbox.checked ? wifiSettingsFieldsContainer.style.display = 'block' : wifiSettingsFieldsContainer.style.display = 'none';
                            provideTimezoneOffsetCheckbox.checked ? timezoneOffsetFieldContainer.style.display = 'block' : timezoneOffsetFieldContainer.style.display = 'none';
                            mappingsConfigFields.style.display = 'block';
                        }
                    }
                } else { // raw mode for command
                    rawFullCommandJsonContainer.style.display = 'block';
                }
            } else if (selectedMessageType === 'customJson') {
                customJsonMessageFieldsDiv.style.display = 'block';
            } else if (selectedMessageType === 'invalidText') {
                invalidTextMessageFieldsDiv.style.display = 'block';
            }
            // For 'emptyPayload', no specific fields are needed.
        }

        messageTypeSelect.addEventListener('change', updateSendUI);
        document.querySelectorAll('input[name="commandInputMode"]').forEach(radio => {
            radio.addEventListener('change', updateSendUI);
        });
        document.querySelectorAll('input[name="setConfigInputMode"]').forEach(radio => {
            radio.addEventListener('change', updateSendUI);
        });
        provideWifiSettingsCheckbox.addEventListener('change', () => { // Toggle for wifi fields
            wifiSettingsFieldsContainer.style.display = provideWifiSettingsCheckbox.checked ? 'block' : 'none';
        });
        provideTimezoneOffsetCheckbox.addEventListener('change', () => { // Toggle for timezone offset field
            timezoneOffsetFieldContainer.style.display = provideTimezoneOffsetCheckbox.checked ? 'block' : 'none';
        });


        // Check if WebUSB is supported
        if (!navigator.usb) {
            statusDisplay.textContent = 'WebUSB is not supported by this browser.';
            connectButton.disabled = true;
            configFieldset.disabled = true;
        }

        connectButton.addEventListener('click', connectDevice);
        disconnectButton.addEventListener('click', disconnectDevice);
        sendButton.addEventListener('click', sendData);

        // Function to parse config values and validate
        function getDeviceConfig() {
            const vidString = vidInput.value.trim();
            const pidString = pidInput.value.trim();
            const interfaceString = interfaceInput.value.trim();
            const epOutString = epOutInput.value.trim();
            const epInString = epInInput.value.trim();

            const vendorId = parseInt(vidString, 16);
            const productId = parseInt(pidString, 16);
            const interfaceNumber = parseInt(interfaceString, 10);
            const endpointOut = parseInt(epOutString, 10);
            const endpointIn = parseInt(epInString, 10);

            if (isNaN(vendorId) || isNaN(productId) || isNaN(interfaceNumber) || isNaN(endpointOut) || isNaN(endpointIn)) {
                alert('Invalid input. Please ensure all fields contain valid numbers (hex for VID/PID, decimal for others).');
                return null;
            }
            if (endpointOut < 1 || endpointIn < 1 || interfaceNumber < 0) {
                alert('Interface must be >= 0, Endpoints must be >= 1.');
                return null;
            }
            return { vendorId, productId, interfaceNumber, endpointOut, endpointIn };
        }

        async function connectDevice() {
            const config = getDeviceConfig();
            if (!config) return;

            currentInterfaceNumber = config.interfaceNumber;
            currentEndpointOut = config.endpointOut;
            currentEndpointIn = config.endpointIn;

            try {
                statusDisplay.textContent = `Requesting device (VID: 0x${config.vendorId.toString(16)}, PID: 0x${config.productId.toString(16)})...`;
                device = await navigator.usb.requestDevice({ filters: [{ vendorId: config.vendorId, productId: config.productId }] });
                if (!device) {
                    statusDisplay.textContent = 'No device selected.';
                    return;
                }
                statusDisplay.textContent = `Connecting to ${device.manufacturerName || 'Unknown'} ${device.productName || 'Device'}...`;
                await device.open();
                if (device.configuration === null) await device.selectConfiguration(1);
                await device.claimInterface(currentInterfaceNumber);
                statusDisplay.textContent = `Connected to ${device.manufacturerName || 'Unknown'} ${device.productName || 'Device'}`;
                connectButton.disabled = true;
                disconnectButton.disabled = false;
                configFieldset.disabled = true;
                controlsDiv.style.display = 'block';
                receiveAreaDiv.style.display = 'block';
                receivedDataTextArea.textContent = '';
                updateSendUI(); // Initialize send UI state
                startReading();
            } catch (error) {
                statusDisplay.textContent = `Error connecting: ${error.message}`;
                console.error('Connection error:', error);
                device = null;
                configFieldset.disabled = false;
            }
        }

        async function disconnectDevice() {
            isReading = false;
            if (!device) {
                configFieldset.disabled = false;
                connectButton.disabled = false;
                disconnectButton.disabled = true;
                controlsDiv.style.display = 'none';
                receiveAreaDiv.style.display = 'none';
                return;
            }
            try {
                statusDisplay.textContent = 'Disconnecting...';
                await device.releaseInterface(currentInterfaceNumber);
                await device.close();
            } catch (error) {
                if (error.name !== 'NotFoundError' && error.name !== 'InvalidStateError') {
                    console.error('Disconnection error:', error);
                }
            } finally {
                device = null;
                statusDisplay.textContent = 'Disconnected.';
                connectButton.disabled = false;
                disconnectButton.disabled = true;
                configFieldset.disabled = false;
                controlsDiv.style.display = 'none';
                receiveAreaDiv.style.display = 'none';
            }
        }

        async function sendData() {
            if (!device) {
                alert('Device not connected.');
                return;
            }

            let messageHeaderBytes;
            try {
                messageHeaderBytes = hexStringToUint8Array(customHeaderInput.value.trim());
            } catch (error) {
                alert(`Error parsing Custom Header: ${error.message}`);
                return;
            }

            const selectedMessageType = messageTypeSelect.value;
            const selectedCommandInputMode = document.querySelector('input[name="commandInputMode"]:checked').value;
            const selectedSetConfigInputMode = document.querySelector('input[name="setConfigInputMode"]:checked').value;
            let payloadString = "";

            try {
                if (selectedMessageType === 'getConfig' || selectedMessageType === 'setConfig') {
                    if (selectedCommandInputMode === 'structured') {
                        const protocolVersion = parseInt(protocolVersionInput.value.trim(), 10);
                        if (isNaN(protocolVersion) || protocolVersion < 0) throw new Error("Protocol Version must be a non-negative number.");
                        let headerObject = { version: protocolVersion };
                        const correlationIdStr = correlationIdInput.value.trim();
                        if (correlationIdStr) {
                            const correlationId = parseInt(correlationIdStr, 10);
                            if (isNaN(correlationId)) throw new Error("Correlation ID must be a number if provided.");
                            headerObject.correlationId = correlationId;
                        }
                        let commandObject = { header: headerObject };

                        if (selectedMessageType === 'getConfig') {
                            commandObject.type = "GetConfig";
                        } else { // setConfig
                            commandObject.type = "SetConfig";
                            let deviceConfig = {};
                            if (selectedSetConfigInputMode === 'json') {
                                const deviceConfigStr = deviceConfigJsonTextarea.value.trim();
                                if (!deviceConfigStr) throw new Error("Device Configuration JSON is required for SetConfig (JSON Mode).");
                                deviceConfig = JSON.parse(deviceConfigStr);
                            } else { // 'fields' mode for setConfig.config
                                let settings = {};
                                if (provideWifiSettingsCheckbox.checked) {
                                    const ssid = wifiSsidInput.value.trim();
                                    const password = wifiPasswordInput.value.trim();
                                    if (!ssid) throw new Error("SSID is required if Wi-Fi settings are provided.");
                                    // Password can be empty
                                    settings.wifi = { ssid, password };
                                }
                                if (provideTimezoneOffsetCheckbox.checked) {
                                    const tzOffsetStr = timezoneOffsetInput.value.trim();
                                    if (!tzOffsetStr) throw new Error("Timezone Offset is required if selected.");
                                    const tzOffset = parseFloat(tzOffsetStr);
                                    if (isNaN(tzOffset)) throw new Error("Invalid Timezone Offset value.");
                                    settings.timezone_offset = tzOffset;
                                }

                                const mappingsJsonStr = mappingsConfigJsonTextarea.value.trim();
                                if (!mappingsJsonStr) throw new Error("Mappings Configuration JSON is required.");
                                const mappings = JSON.parse(mappingsJsonStr); // Can throw

                                deviceConfig.settings = settings;
                                deviceConfig.mappings = mappings;
                            }
                            commandObject.config = deviceConfig;
                        }
                        payloadString = JSON.stringify(commandObject);
                    } else { // raw mode for command
                        payloadString = rawFullCommandJsonTextarea.value.trim();
                        if (!payloadString) throw new Error("Raw Full Command JSON cannot be empty.");
                        JSON.parse(payloadString); // Validate JSON structure
                    }
                } else if (selectedMessageType === 'customJson') {
                    payloadString = customJsonMessageTextarea.value;
                    if (payloadString) JSON.parse(payloadString); // Optional: validate if it should be JSON
                } else if (selectedMessageType === 'invalidText') {
                    payloadString = invalidTextMessageTextarea.value;
                } else if (selectedMessageType === 'emptyPayload') {
                    payloadString = ""; // Explicitly empty
                }
            } catch (error) {
                alert(`Error preparing payload: ${error.message}`);
                console.error("Error preparing payload:", error);
                return;
            }

            const payloadBodyBytes = new TextEncoder().encode(payloadString);
            const payloadLength = payloadBodyBytes.length;
            const messageLengthBytes = u32ToBigEndianBytes(payloadLength);

            const finalMessage = new Uint8Array(messageHeaderBytes.length + messageLengthBytes.length + payloadBodyBytes.length);
            finalMessage.set(messageHeaderBytes, 0);
            finalMessage.set(messageLengthBytes, messageHeaderBytes.length);
            finalMessage.set(payloadBodyBytes, messageHeaderBytes.length + messageLengthBytes.length);

            try {
                console.log(`Sending message: Header=${Array.from(messageHeaderBytes).map(b => b.toString(16).padStart(2, '0')).join('')}, Length=${payloadLength}, Payload (first 100 bytes)=${new TextDecoder().decode(payloadBodyBytes.slice(0, 100))}`);
                console.log("Full message bytes:", finalMessage);
                const result = await device.transferOut(currentEndpointOut, finalMessage);
                console.log('Transfer OUT result:', result);
                if (result.status !== 'ok') {
                    statusDisplay.textContent = `Send Error: ${result.status}`;
                }
            } catch (error) {
                statusDisplay.textContent = `Error sending data: ${error.message}`;
                console.error('Send data error:', error);
                if (error.message.includes("disconnected") || error.name === "NotFoundError" || error.message.includes("The device was disconnected") || error.message.includes("No such interface")) {
                    await disconnectDevice();
                }
            }
        }

        async function startReading() {
            if (isReading || !device) return;
            isReading = true;
            console.log(`Starting read loop for endpoint ${currentEndpointIn}...`);
            // Reset buffer and state when starting to read
            receiveBuffer = new Uint8Array(0);
            receiveState = 'AWAITING_MAGIC_WORD';
            expectedPayloadLength = 0;

            while (isReading && device?.opened) {
                try {
                    const result = await device.transferIn(currentEndpointIn, 64); // Read up to 64 bytes (common packet size)

                    if (result.data) { // Check if result.data is not null/undefined
                        if (result.data.byteLength > 0) {
                            receiveBuffer = appendBuffer(receiveBuffer, result.data.buffer);
                            console.log(`Received ${result.data.byteLength} bytes. Buffer size: ${receiveBuffer.length}`);
                            receivedDataTextArea.textContent += `[DEBUG] Received ${result.data.byteLength} raw bytes. Buffer: ${receiveBuffer.length}\n`; // Temporary direct log to textarea
                            processReceiveBuffer(); // Process any complete messages in the buffer
                        } else {
                            // Log if zero bytes are received, if result.data exists
                            console.log("Poll returned 0 bytes from device.transferIn.");
                            // Optionally, uncomment to add a debug message to textarea for this specific case if helpful
                            // receivedDataTextArea.textContent += "[DEBUG] Poll returned 0 bytes.\n";
                        }
                    } else {
                        // This case implies an issue with the transferIn result structure if no error was thrown
                        console.warn("device.transferIn result.data is null or undefined, but no error thrown.");
                        receivedDataTextArea.textContent += "[WARN] transferIn result.data was null/undefined.\n";
                    }

                    // Check for non-OK status after processing data, as 'stall' might still have data.
                    if (result.status !== 'ok') {
                        if (result.status === 'stall') {
                            console.warn('Endpoint stalled. Clearing halt.');
                            await device.clearHalt('in', currentEndpointIn);
                        } else {
                            statusDisplay.textContent = `Read Error: ${result.status}`;
                            console.error(`Read Error: ${result.status}`);
                            isReading = false; // Stop reading on other errors
                            break;
                        }
                    }
                } catch (error) {
                    if (isReading) { // Only update status if we were still supposed to be reading
                        statusDisplay.textContent = `Error reading data: ${error.message}`;
                        console.error('Read loop error:', error);
                    }
                    isReading = false; // Stop reading on exception
                    // Check if the error is due to disconnection
                    if (error.message.includes("disconnected") || error.name === "NotFoundError" || error.message.includes("The device was disconnected") || error.message.includes("No such interface")) {
                        console.log("Device appears to be disconnected, ensuring UI reflects this.");
                        await disconnectDevice(); // Ensure full disconnection logic is triggered
                    }
                    break;
                }
            }
            isReading = false; // Ensure isReading is false when loop exits
            console.log("Read loop stopped.");
        }

        navigator.usb.getDevices().then(devices => {
            if (devices.length > 0) console.log("Found previously granted devices:", devices);
        });

        navigator.usb.addEventListener('disconnect', async (event) => {
            if (device && event.device === device) {
                console.log(`Connected device ${device.productName || 'Device'} disconnected.`);
                await disconnectDevice();
            }
        });

        // Initial UI setup
        updateSendUI();

    </script>

</body>

</html>