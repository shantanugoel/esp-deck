<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Configurable WebUSB Sender/Receiver</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 1em;
        }

        #status {
            margin-bottom: 1em;
            font-weight: bold;
        }

        #config input,
        #sendConfig input,
        #sendConfig select,
        #sendConfig textarea {
            margin-bottom: 0.5em;
            padding: 5px;
        }

        #config label,
        #sendConfig label {
            display: inline-block;
            width: 160px;
            /* Adjusted for potentially longer labels */
            text-align: right;
            margin-right: 5px;
            vertical-align: middle;
        }

        #sendConfig label[for^="deviceConfigJson"],
        #sendConfig label[for^="rawJsonPayload"],
        #sendConfig label[for^="invalidTextPayload"] {
            display: block;
            text-align: left;
            width: auto;
            margin-bottom: 3px;
        }


        #config,
        #sendConfig {
            border: 1px solid #eee;
            padding: 1em;
            margin-bottom: 1em;
            background-color: #f9f9f9;
        }

        #sendConfig fieldset {
            margin-top: 10px;
            border: 1px dashed #ccc;
            padding: 10px;
        }

        #sendConfig legend {
            font-weight: bold;
        }


        #controls,
        #receiveArea {
            margin-top: 1em;
        }

        #receivedData {
            width: 95%;
            height: 200px;
            border: 1px solid #ccc;
            overflow-y: scroll;
            white-space: pre-wrap;
            font-family: monospace;
            margin-top: 0.5em;
            padding: 5px;
        }

        button {
            margin-right: 5px;
            padding: 5px 10px;
        }

        /* input[type="text"]#dataToSend {
            padding: 5px;
            min-width: 200px;
            margin-right: 5px;
        }

        label[for="dataToSend"] {
            display: block;
            margin-bottom: 0.5em;
        } */
    </style>
</head>

<body>

    <h1>WebUSB Configurable Communication</h1>

    <div id="status">Disconnected.</div>

    <fieldset id="config">
        <legend>Device Configuration</legend>
        <div>
            <label for="vid">Vendor ID (hex):</label>
            <input type="text" id="vid" value="0x5AA6">
        </div>
        <div>
            <label for="pid">Product ID (hex):</label>
            <input type="text" id="pid" value="0x60E1">
        </div>
        <div>
            <label for="interface">Interface #:</label>
            <input type="number" id="interface" value="1" min="0">
        </div>
        <div>
            <label for="epOut">OUT Endpoint #:</label>
            <input type="number" id="epOut" value="2" min="1">
        </div>
        <div>
            <label for="epIn">IN Endpoint #:</label>
            <input type="number" id="epIn" value="2" min="1">
        </div>
    </fieldset>

    <button id="connectButton">Connect to USB Device</button>
    <button id="disconnectButton" disabled>Disconnect</button>

    <div id="controls" style="display: none;">
        <hr>
        <fieldset id="sendConfig">
            <legend>Send Data</legend>
            <div>
                <label for="customHeader">Message Header (4-byte hex):</label>
                <input type="text" id="customHeader" value="E59DECC0" maxlength="8" style="width: 100px;">
            </div>
            <br>

            <div>
                <label for="commandType">Command / Payload Type:</label>
                <select id="commandType">
                    <option value="getConfig" selected>GetConfig Command</option>
                    <option value="setConfig">SetConfig Command</option>
                    <option value="rawJson">Raw JSON Payload</option>
                    <option value="invalidText">Invalid Text Payload</option>
                    <option value="emptyPayload">Empty Payload (Length 0)</option>
                </select>
            </div>

            <fieldset id="protocolHeaderFields">
                <legend>Protocol Header Fields</legend>
                <div>
                    <label for="protocolVersion">Version (uint32):</label>
                    <input type="number" id="protocolVersion" value="65536"> <!-- 0x00010000 -->
                </div>
                <div>
                    <label for="correlationId">Correlation ID (number, opt.):</label>
                    <input type="text" id="correlationId" placeholder="e.g., 12345 (optional)">
                </div>
            </fieldset>

            <fieldset id="setConfigFields" style="display:none;">
                <legend>SetConfig Specific Fields</legend>
                <div>
                    <label for="deviceConfigJson">Device Configuration (JSON format):</label>
                    <textarea id="deviceConfigJson" rows="4" style="width: 90%;"
                        placeholder='''{"brightness": 100, "power_on": true}'''></textarea>
                </div>
            </fieldset>

            <fieldset id="rawJsonPayloadFields" style="display:none;">
                <legend>Raw JSON Payload</legend>
                <textarea id="rawJsonPayload" rows="4" style="width: 90%;"
                    placeholder='''{"type": "GetConfig", "header": {"version": 65536}}'''></textarea>
            </fieldset>

            <fieldset id="invalidTextPayloadFields" style="display:none;">
                <legend>Invalid Text Payload</legend>
                <textarea id="invalidTextPayload" rows="4" style="width: 90%;"
                    placeholder='''This is not JSON {type: GetConfig}'''></textarea>
            </fieldset>


            <button id="sendButton" style="margin-top:15px;">Send Message</button>
        </fieldset>
    </div>

    <div id="receiveArea" style="display: none;">
        <h2>Received Data</h2>
        <pre id="receivedData"></pre>
    </div>

    <script>
        // References to Configuration Inputs
        const vidInput = document.getElementById('vid');
        const pidInput = document.getElementById('pid');
        const interfaceInput = document.getElementById('interface');
        const epOutInput = document.getElementById('epOut');
        const epInInput = document.getElementById('epIn');

        // Other UI References
        const connectButton = document.getElementById('connectButton');
        const disconnectButton = document.getElementById('disconnectButton');
        const sendButton = document.getElementById('sendButton');
        // const dataToSendInput = document.getElementById('dataToSend'); // Removed
        const receivedDataTextArea = document.getElementById('receivedData');
        const statusDisplay = document.getElementById('status');
        const controlsDiv = document.getElementById('controls');
        const receiveAreaDiv = document.getElementById('receiveArea');
        const configFieldset = document.getElementById('config');

        // New UI elements for sending data
        const customHeaderInput = document.getElementById('customHeader');
        const commandTypeSelect = document.getElementById('commandType');
        const protocolHeaderFieldsDiv = document.getElementById('protocolHeaderFields');
        const protocolVersionInput = document.getElementById('protocolVersion');
        const correlationIdInput = document.getElementById('correlationId');
        const setConfigFieldsDiv = document.getElementById('setConfigFields');
        const deviceConfigJsonTextarea = document.getElementById('deviceConfigJson');
        const rawJsonPayloadFieldsDiv = document.getElementById('rawJsonPayloadFields');
        const rawJsonPayloadTextarea = document.getElementById('rawJsonPayload');
        const invalidTextPayloadFieldsDiv = document.getElementById('invalidTextPayloadFields');
        const invalidTextPayloadTextarea = document.getElementById('invalidTextPayload');


        let device = null;
        let isReading = false; // Flag to prevent multiple read loops
        // Store parsed config values for the current connection
        let currentInterfaceNumber = 0;
        let currentEndpointOut = 0;
        let currentEndpointIn = 0;


        // Helper function to convert a hex string to Uint8Array
        function hexStringToUint8Array(hexString) {
            if (hexString.startsWith('0x')) {
                hexString = hexString.substring(2);
            }
            // Ensure 8 hex characters for 4 bytes.
            if (hexString.length !== 8) {
                throw new Error("Hex header must be exactly 4 bytes (8 hex characters). Example: E59DECC0");
            }
            if (!/^[0-9a-fA-F]{8}$/.test(hexString)) {
                throw new Error("Hex header contains invalid characters. Only 0-9 and A-F are allowed.");
            }

            const byteArray = new Uint8Array(4); // Always 4 bytes
            for (let i = 0; i < 4; i++) {
                byteArray[i] = parseInt(hexString.substring(i * 2, i * 2 + 2), 16);
                if (isNaN(byteArray[i])) { // Should be caught by regex, but good for safety
                    throw new Error(`Invalid hex character sequence in header at byte ${i}`);
                }
            }
            return byteArray;
        }

        // Helper function to convert a u32 number to a 4-byte Big Endian Uint8Array
        function u32ToBigEndianBytes(num) {
            const buffer = new ArrayBuffer(4);
            const view = new DataView(buffer);
            view.setUint32(0, num, false); // false for big-endian
            return new Uint8Array(buffer);
        }

        // Update UI based on command type selection
        commandTypeSelect.addEventListener('change', function () {
            const selectedType = this.value;
            protocolHeaderFieldsDiv.style.display = 'none';
            setConfigFieldsDiv.style.display = 'none';
            rawJsonPayloadFieldsDiv.style.display = 'none';
            invalidTextPayloadFieldsDiv.style.display = 'none';

            if (selectedType === 'getConfig' || selectedType === 'setConfig') {
                protocolHeaderFieldsDiv.style.display = 'block';
                if (selectedType === 'setConfig') {
                    setConfigFieldsDiv.style.display = 'block';
                }
            } else if (selectedType === 'rawJson') {
                rawJsonPayloadFieldsDiv.style.display = 'block';
            } else if (selectedType === 'invalidText') {
                invalidTextPayloadFieldsDiv.style.display = 'block';
            }
            // For 'emptyPayload', no specific fields are needed beyond the main header.
        });


        // Check if WebUSB is supported
        if (!navigator.usb) {
            statusDisplay.textContent = 'WebUSB is not supported by this browser.';
            connectButton.disabled = true;
            configFieldset.disabled = true;
        }

        connectButton.addEventListener('click', connectDevice);
        disconnectButton.addEventListener('click', disconnectDevice);
        sendButton.addEventListener('click', sendData);

        // Function to parse config values and validate
        function getDeviceConfig() {
            const vidString = vidInput.value.trim();
            const pidString = pidInput.value.trim();
            const interfaceString = interfaceInput.value.trim();
            const epOutString = epOutInput.value.trim();
            const epInString = epInInput.value.trim();

            const vendorId = parseInt(vidString, 16);
            const productId = parseInt(pidString, 16);
            const interfaceNumber = parseInt(interfaceString, 10);
            const endpointOut = parseInt(epOutString, 10);
            const endpointIn = parseInt(epInString, 10);

            if (isNaN(vendorId) || isNaN(productId) || isNaN(interfaceNumber) || isNaN(endpointOut) || isNaN(endpointIn)) {
                alert('Invalid input. Please ensure all fields contain valid numbers (hex for VID/PID, decimal for others).');
                return null;
            }
            if (endpointOut < 1 || endpointIn < 1 || interfaceNumber < 0) {
                alert('Interface must be >= 0, Endpoints must be >= 1.');
                return null;
            }

            return { vendorId, productId, interfaceNumber, endpointOut, endpointIn };
        }


        // Function to request device access and connect
        async function connectDevice() {
            const config = getDeviceConfig();
            if (!config) {
                return; // Validation failed
            }
            // Store config for use in send/receive
            currentInterfaceNumber = config.interfaceNumber;
            currentEndpointOut = config.endpointOut;
            currentEndpointIn = config.endpointIn;

            try {
                statusDisplay.textContent = `Requesting device (VID: 0x${config.vendorId.toString(16)}, PID: 0x${config.productId.toString(16)})...`;
                console.log('Requesting device with filters:', { vendorId: config.vendorId, productId: config.productId });

                // Request permission from the user using values from inputs
                device = await navigator.usb.requestDevice({
                    filters: [{ vendorId: config.vendorId, productId: config.productId }]
                });

                if (!device) {
                    statusDisplay.textContent = 'No device selected.';
                    return;
                }

                statusDisplay.textContent = `Connecting to ${device.manufacturerName || 'Unknown'} ${device.productName || 'Device'}...`;
                console.log('Device selected:', device);

                await device.open();
                console.log('Device opened.');

                if (device.configuration === null) {
                    await device.selectConfiguration(1); // Select the first configuration
                    console.log('Configuration 1 selected.');
                } else {
                    console.log(`Device already has configuration ${device.configuration.configurationValue} selected.`);
                }

                await device.claimInterface(currentInterfaceNumber); // Use parsed value
                console.log(`Interface ${currentInterfaceNumber} claimed.`);

                statusDisplay.textContent = `Connected to ${device.manufacturerName || 'Unknown'} ${device.productName || 'Device'}`;
                connectButton.disabled = true;
                disconnectButton.disabled = false;
                configFieldset.disabled = true; // Disable config inputs while connected
                controlsDiv.style.display = 'block';
                receiveAreaDiv.style.display = 'block';
                receivedDataTextArea.textContent = ''; // Clear receive area
                // Trigger change event on load to set initial visibility of command fields
                commandTypeSelect.dispatchEvent(new Event('change'));

                startReading();

            } catch (error) {
                statusDisplay.textContent = `Error connecting: ${error.message}`;
                console.error('Connection error:', error);
                device = null;
                configFieldset.disabled = false; // Re-enable config inputs on error
            }
        }

        // Function to disconnect
        async function disconnectDevice() {
            isReading = false; // Signal read loop to stop
            if (!device) {
                console.log("Already disconnected.");
                configFieldset.disabled = false; // Ensure inputs enabled
                connectButton.disabled = false;
                disconnectButton.disabled = true;
                controlsDiv.style.display = 'none';
                receiveAreaDiv.style.display = 'none';
                return;
            }
            try {
                statusDisplay.textContent = 'Disconnecting...';
                // Make sure to use the interface number used during connection
                await device.releaseInterface(currentInterfaceNumber);
                console.log(`Interface ${currentInterfaceNumber} released.`);
                await device.close();
                console.log('Device closed.');

            } catch (error) {
                // Ignore errors if device is already gone or interface not claimed
                if (error.name !== 'NotFoundError' && error.name !== 'InvalidStateError') {
                    statusDisplay.textContent = `Error disconnecting: ${error.message}`;
                    console.error('Disconnection error:', error);
                }
            } finally {
                device = null;
                statusDisplay.textContent = 'Disconnected.';
                connectButton.disabled = false;
                disconnectButton.disabled = true;
                configFieldset.disabled = false; // Re-enable config inputs
                controlsDiv.style.display = 'none';
                receiveAreaDiv.style.display = 'none';
            }
        }

        // Function to send data
        async function sendData() {
            if (!device) {
                alert('Device not connected.');
                return;
            }

            let messageHeaderBytes;
            try {
                const customHeaderStr = customHeaderInput.value.trim();
                messageHeaderBytes = hexStringToUint8Array(customHeaderStr); // hexStringToUint8Array validates length and format
            } catch (error) {
                alert(`Error parsing Custom Header: ${error.message}`);
                return;
            }

            const commandType = commandTypeSelect.value;
            let payloadBodyBytes = new Uint8Array(0); // Default to empty payload

            try {
                let jsonPayloadString = "";

                if (commandType === 'getConfig' || commandType === 'setConfig') {
                    const protocolVersionStr = protocolVersionInput.value.trim();
                    const correlationIdStr = correlationIdInput.value.trim();

                    if (!protocolVersionStr) {
                        alert("Protocol Version is required.");
                        return;
                    }
                    const protocolVersion = parseInt(protocolVersionStr, 10);
                    if (isNaN(protocolVersion) || protocolVersion < 0) {
                        alert("Invalid Protocol Version. Must be a non-negative number.");
                        return;
                    }

                    let headerObject = { version: protocolVersion };
                    if (correlationIdStr) {
                        const correlationId = parseInt(correlationIdStr, 10);
                        if (isNaN(correlationId)) {
                            alert("Invalid Correlation ID. Must be a number if provided.");
                            return;
                        }
                        headerObject.correlationId = correlationId;
                    }

                    let commandObject = {};
                    if (commandType === 'getConfig') {
                        commandObject = { type: "GetConfig", header: headerObject };
                    } else { // setConfig
                        const deviceConfigStr = deviceConfigJsonTextarea.value.trim();
                        if (!deviceConfigStr) {
                            alert("Device Configuration JSON is required for SetConfig.");
                            return;
                        }
                        try {
                            const deviceConfig = JSON.parse(deviceConfigStr);
                            commandObject = { type: "SetConfig", header: headerObject, config: deviceConfig };
                        } catch (e) {
                            alert(`Invalid JSON in Device Configuration: ${e.message}`);
                            return;
                        }
                    }
                    jsonPayloadString = JSON.stringify(commandObject);
                } else if (commandType === 'rawJson') {
                    jsonPayloadString = rawJsonPayloadTextarea.value;
                    // Optionally validate if it's JSON, or let the device handle it
                    try { if (jsonPayloadString) JSON.parse(jsonPayloadString); } catch (e) { /* ignore, it's "raw" */ }
                } else if (commandType === 'invalidText') {
                    jsonPayloadString = invalidTextPayloadTextarea.value;
                } else if (commandType === 'emptyPayload') {
                    // jsonPayloadString remains empty, payloadBodyBytes will be empty, length will be 0
                }

                if (jsonPayloadString) { // If there's a string payload to encode
                    payloadBodyBytes = new TextEncoder().encode(jsonPayloadString);
                }

            } catch (error) {
                alert(`Error preparing payload: ${error.message}`);
                console.error("Error preparing payload:", error);
                return;
            }

            const payloadLength = payloadBodyBytes.length;
            const messageLengthBytes = u32ToBigEndianBytes(payloadLength);

            const finalMessage = new Uint8Array(messageHeaderBytes.length + messageLengthBytes.length + payloadBodyBytes.length);
            finalMessage.set(messageHeaderBytes, 0);
            finalMessage.set(messageLengthBytes, messageHeaderBytes.length);
            finalMessage.set(payloadBodyBytes, messageHeaderBytes.length + messageLengthBytes.length);

            try {
                console.log(`Sending message: Header=${Array.from(messageHeaderBytes).map(b => b.toString(16).padStart(2, '0')).join('')}, Length=${payloadLength}, Payload (first 50 bytes)=${new TextDecoder().decode(payloadBodyBytes.slice(0, 50))}`);
                console.log("Full message bytes:", finalMessage);
                const result = await device.transferOut(currentEndpointOut, finalMessage);
                console.log('Transfer OUT result:', result);

                if (result.status !== 'ok') {
                    statusDisplay.textContent = `Send Error: ${result.status}`;
                    console.error('Send Error Status:', result.status);
                } else {
                    // Optionally clear some fields after successful send
                    // e.g. rawJsonPayloadTextarea.value = '';
                }

            } catch (error) {
                statusDisplay.textContent = `Error sending data: ${error.message}`;
                console.error('Send data error:', error);
                if (error.message.includes("disconnected") || error.name === "NotFoundError" || error.message.includes("The device was disconnected") || error.message.includes("No such interface")) {
                    await disconnectDevice(); // Ensure full disconnect logic runs
                }
            }
        }

        // Function to continuously read data from the IN endpoint
        async function startReading() {
            if (isReading || !device) return;
            isReading = true;
            // Use the endpoint number stored during connection
            console.log(`Starting read loop for endpoint ${currentEndpointIn}...`);

            while (isReading && device?.opened) {
                try {
                    // Use stored IN endpoint number
                    const result = await device.transferIn(currentEndpointIn, 64); // Read up to 64 bytes

                    if (result.data && result.data.byteLength > 0) {
                        const decoder = new TextDecoder();
                        const text = decoder.decode(result.data);
                        console.log('Received Text:', text);
                        receivedDataTextArea.textContent += text;
                        receivedDataTextArea.scrollTop = receivedDataTextArea.scrollHeight;
                    }

                    if (result.status !== 'ok') {
                        if (result.status === 'stall') {
                            console.warn(`Endpoint ${currentEndpointIn} stalled. Attempting to clear halt.`);
                            await device.clearHalt('in', currentEndpointIn);
                        } else {
                            console.error(`Read Error Status: ${result.status}. Stopping read loop.`);
                            statusDisplay.textContent = `Read Error: ${result.status}`;
                            isReading = false; // Stop reading on non-stall errors
                            break;
                        }
                    }
                } catch (error) {
                    console.error('Read loop error:', error);
                    if (isReading) { // Only update status if we were still trying to read
                        statusDisplay.textContent = `Error reading data: ${error.message}`;
                    }
                    isReading = false; // Stop reading on any catch
                    if (error.message.includes("disconnected") || error.name === "NotFoundError" || error.message.includes("The device was disconnected")) {
                        // The 'disconnect' event listener will handle the UI updates for disconnection.
                    }
                    break; // Exit loop on error
                }
            }
            isReading = false;
            console.log("Read loop stopped.");
        }

        // Check for previously granted devices on page load
        navigator.usb.getDevices().then(async (devices) => {
            if (devices.length > 0) {
                console.log("Found previously granted devices:", devices);
                // You could attempt to auto-connect to the first one, or list them.
                // For now, just logging.
            }
        });

        // Listen for device disconnection events
        navigator.usb.addEventListener('disconnect', async (event) => {
            console.log('Device disconnect event:', event);
            if (device && event.device === device) {
                console.log(`Connected device ${device.productName || 'Device'} disconnected.`);
                // Ensure we call our disconnectDevice function to clean up state and UI
                await disconnectDevice();
            }
        });

    </script>

</body>

</html>